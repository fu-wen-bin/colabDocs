<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/Button.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/Button.css" />
              <option name="updatedContent" value=".button {&#10;  background-color: #3b82f6;&#10;  color: #eff6ff;&#10;  padding: 0.5rem 1rem;&#10;  border-radius: 0.375rem;&#10;  transition: color 0.2s;&#10;}&#10;&#10;/* 确保:hover选择器位于.button之后，提高特异性 */&#10;.button:hover {&#10;  color: #22c55e; /* 绿色 */&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/Button.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/Button.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;&#10;interface ButtonProps {&#10;  children: React.ReactNode;&#10;  className?: string;&#10;  onClick?: () =&gt; void;&#10;}&#10;&#10;export default function Button({ children, className = '', onClick }: ButtonProps) {&#10;  // 添加hover:text-green-500类来实现悬浮时文字变绿&#10;  return (&#10;    &lt;button &#10;      className={`bg-blue-500 text-blue-50 px-4 py-2 rounded-md hover:text-green-500 transition-colors ${className}`}&#10;      onClick={onClick}&#10;    &gt;&#10;      {children}&#10;    &lt;/button&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/StyledButton.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/StyledButton.tsx" />
              <option name="updatedContent" value="import styled from 'styled-components';&#10;&#10;const StyledButton = styled.button`&#10;  background-color: #3b82f6;&#10;  color: #eff6ff;&#10;  padding: 0.5rem 1rem;&#10;  border-radius: 0.375rem;&#10;  transition: color 0.2s;&#10;  &#10;  &amp;:hover {&#10;    color: #22c55e; /* 绿色 */&#10;  }&#10;`;&#10;&#10;export default StyledButton;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/TableOfContents/index.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/TableOfContents/index.css" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/tiptap-ui-primitive/button.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/tiptap-ui-primitive/button.tsx" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/components/tiptap-ui-primitive/spacer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/components/tiptap-ui-primitive/spacer.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;&#10;export function Spacer() {&#10;  return &lt;div className=&quot;flex-1&quot; /&gt;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/pages/Auth/callback.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/pages/Auth/callback.tsx" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/colab-docs/src/styles/globals.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/colab-docs/src/styles/globals.css" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mouse-cursor-effect.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mouse-cursor-effect.html" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/node-oauth-demo/routes/githubOauth.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/node-oauth-demo/routes/githubOauth.js" />
              <option name="updatedContent" value="const Router = require('@koa/router')&#10;const axios = require('axios')&#10;const router = new Router()&#10;&#10;// Fill in your client ID and client secret that you obtained&#10;// while registering the application&#10;const clientID = '7e015d8ce32370079895'&#10;const clientSecret = '2b976af0e6b6ceea2b1554aa31d1fe94ea692cd9'&#10;&#10;router.get('/oauth/redirect', async ctx =&gt; {&#10;  const requestToken = ctx.request.query.code&#10;  console.log('authorization code:', requestToken)&#10;&#10;  const tokenResponse = await axios({&#10;    method: 'post',&#10;    url: 'https://github.com/login/oauth/access_token?' +&#10;         `client_id=${clientID}&amp;` +&#10;         `client_secret=${clientSecret}&amp;` +&#10;         `code=${requestToken}`,&#10;    headers: {&#10;      accept: 'application/json',&#10;    },&#10;  })&#10;&#10;  const accessToken = tokenResponse.data.access_token&#10;  const data = tokenResponse.data&#10;  console.log('token response:', data)&#10;  console.log(`access token: ${accessToken}`)&#10;&#10;  const result = await axios({&#10;    method: 'get',&#10;    url: `https://api.github.com/user`,&#10;    headers: {&#10;      accept: 'application/json',&#10;      Authorization: `token ${accessToken}`,&#10;    },&#10;  })&#10;  console.log(result.data)&#10;  const name = result.data.name&#10;&#10;  ctx.response.redirect(`/welcome.html?name=${name}`)&#10;})&#10;&#10;module.exports = router&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/app.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/app.js" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/config/index.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/config/index.js" />
              <option name="originalContent" value="const config = {&#10;  db: {&#10;    host: 'localhost',&#10;    port: '3306',&#10;    user: 'root',&#10;    password: '123456',&#10;    database: 'colabdocs',&#10;  },&#10;}&#10;&#10;// 数据库相关操作&#10;const mysql = require('mysql2/promise')&#10;&#10;// 创建数据库连接池&#10;const pool = mysql.createPool({&#10;  host: config.db.host,&#10;  port: config.db.port,&#10;  user: config.db.user,&#10;  password: config.db.password,&#10;  database: config.db.database,&#10;})&#10;&#10;// 执行sql查询&#10;const allServices = {&#10;  async query (sql, values) {&#10;    try {&#10;      // 使用连接池执行查询&#10;      const conn = await pool.getConnection()&#10;      // 执行各种增删改查的sql语句操作&#10;      const [rows] = await conn.query(sql, values) // rows是查询结果，fields是字段信息&#10;      // 释放连接&#10;      conn.release()  // 修改这里：使用conn.release()而不是pool.releaseConnection&#10;      // 返回查询结果&#10;      return Promise.resolve(rows)&#10;    } catch (error) {&#10;      // 发生错误时，返回错误信息&#10;      return Promise.reject(error)&#10;    }&#10;  },&#10;  &#10;  // 添加获取连接的方法&#10;  async getConnection() {&#10;    return pool.getConnection();&#10;  }&#10;}&#10;&#10;module.exports = {&#10;  allServices,&#10;}" />
              <option name="updatedContent" value="const config = {&#10;  db: {&#10;    host: 'localhost',&#10;    port: '3306',&#10;    user: 'root',&#10;    password: '123456',&#10;    database: 'colabdocs',&#10;  },&#10;}&#10;&#10;// 数据库相关操作&#10;const mysql = require('mysql2/promise')&#10;&#10;// 创建数据库连接池&#10;const pool = mysql.createPool({&#10;  host: config.db.host,&#10;  port: config.db.port,&#10;  user: config.db.user,&#10;  password: config.db.password,&#10;  database: config.db.database,&#10;})&#10;&#10;// 执行sql查询&#10;const allServices = {&#10;  async query (sql, values) {&#10;    try {&#10;      // 使用连接池执行查询&#10;      const conn = await pool.getConnection()&#10;      // 执行各种增删改查的sql语句操作&#10;      const [rows] = await conn.query(sql, values) // rows是查询结果，fields是字段信息&#10;      // 释放连接&#10;      conn.release()  // 修改这里：使用conn.release()而不是pool.releaseConnection&#10;      // 返回查询结果&#10;      return Promise.resolve(rows)&#10;    } catch (error) {&#10;      // 发生错误时，返回错误信息&#10;      return Promise.reject(error)&#10;    }&#10;  },&#10;  &#10;  // 添加获取连接的方法&#10;  async getConnection() {&#10;    return pool.getConnection();&#10;  }&#10;}&#10;&#10;module.exports = {&#10;  allServices,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/Documents/index.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/Documents/index.js" />
              <option name="originalContent" value="const { allServices } = require('../../config')&#10;const { nanoid } = require('nanoid')&#10;&#10;// 根据文件Id查找文件内容&#10;const findContent = (data) =&gt; {&#10;  // 1. 构建查询语句&#10;  const sql = 'SELECT content FROM documents_content WHERE document_id = ?'&#10;  // 2. 执行查询&#10;  return allServices.query(sql,[data.fileId])&#10;}&#10;&#10;// 获取用户的文档列表&#10;const getDocumentList = (userId) =&gt; {&#10;  // 查询用户创建的文档和作为协作者的文档&#10;  const sql = `&#10;    SELECT DISTINCT&#10;      d.id,&#10;      d.doc_name,&#10;      d.owner_id,&#10;      d.created_at,&#10;      d.updated_at,&#10;      CASE &#10;        WHEN d.owner_id = ? THEN 'owner'&#10;        ELSE 'editor'&#10;      END as role&#10;    FROM documents d&#10;    LEFT JOIN document_collaborators dc ON d.id = dc.document_id&#10;    WHERE d.status = 'active' &#10;      AND (d.owner_id = ? OR dc.user_id = ?)&#10;    ORDER BY d.updated_at DESC&#10;  `&#10;  // 执行查询，传入三个相同的userId参数&#10;  return allServices.query(sql, [userId, userId, userId])&#10;}&#10;&#10;// 创建新文档&#10;const createDocument = async (data) =&gt; {&#10;  const { name, userId } = data&#10;&#10;  // 生成唯一的文档ID&#10;  const documentId = nanoid()&#10;&#10;  // 开启事务 -- 专用连接&#10;  const connection = await allServices.getConnection()&#10;&#10;  try {&#10;    await connection.beginTransaction()&#10;&#10;    // 1. 插入文档基本信息&#10;    const insertDocSql = `&#10;      INSERT INTO documents (id, doc_name, owner_id, status) &#10;      VALUES (?, ?, ?, 'active')&#10;    `&#10;    await connection.query(insertDocSql, [documentId, name, userId])&#10;&#10;    // 2. 插入初始内容（空文档）&#10;    const insertContentSql = `&#10;      INSERT INTO documents_content (document_id, content) &#10;      VALUES (?, ?)&#10;    `&#10;    // 初始化一个空的 Tiptap 文档结构&#10;    const initialContent = JSON.stringify({&#10;      type: 'doc',&#10;      content: [{&#10;        type: 'paragraph',&#10;        content: []&#10;      }]&#10;    })&#10;    await connection.query(insertContentSql, [documentId, initialContent])&#10;&#10;    // 3. 将创建者添加到协作者表&#10;    const insertCollaboratorSql = `&#10;      INSERT INTO document_collaborators (document_id, user_id, role) &#10;      VALUES (?, ?, 'owner')&#10;    `&#10;    await connection.query(insertCollaboratorSql, [documentId, userId])&#10;&#10;    // 提交事务&#10;    await connection.commit()&#10;&#10;    return { success: true, documentId }&#10;  } catch (error) {&#10;    // 回滚事务&#10;    await connection.rollback()&#10;    throw error&#10;  } finally {&#10;    // 释放连接&#10;    connection.release()&#10;  }&#10;}&#10;&#10;// 删除文档（软删除）&#10;const deleteDocument = async (data) =&gt; {&#10;  const { fileId, userId } = data&#10;&#10;  // 先检查用户是否有权限删除（必须是文档所有者）&#10;  const checkOwnerSql = 'SELECT owner_id FROM documents WHERE id = ? AND status = &quot;active&quot;'&#10;  const [doc] = await allServices.query(checkOwnerSql, [fileId])&#10;&#10;  if (!doc) {&#10;    throw new Error('文档不存在')&#10;  }&#10;&#10;  if (doc.owner_id !== userId) {&#10;    throw new Error('您没有权限删除此文档')&#10;  }&#10;&#10;  // 执行软删除&#10;  const sql = 'UPDATE documents SET status = &quot;deleted&quot; WHERE id = ?'&#10;  const result = await allServices.query(sql, [fileId])&#10;&#10;  return { success: result.affectedRows &gt; 0 }&#10;}&#10;&#10;// 重命名文档&#10;const renameDocument = async (data) =&gt; {&#10;  const { fileId, newName, userId } = data&#10;&#10;  // 检查用户是否有权限（所有者或协作者都可以重命名）&#10;  const checkPermissionSql = `&#10;    SELECT 1 FROM documents d&#10;    LEFT JOIN document_collaborators dc ON d.id = dc.document_id&#10;    WHERE d.id = ? &#10;      AND d.status = 'active'&#10;      AND (d.owner_id = ? OR dc.user_id = ?)&#10;    LIMIT 1&#10;  `&#10;  const permission = await allServices.query(checkPermissionSql, [fileId, userId, userId])&#10;&#10;  if (!permission || permission.length === 0) {&#10;    throw new Error('您没有权限重命名此文档')&#10;  }&#10;&#10;  // 执行重命名&#10;  const sql = 'UPDATE documents SET doc_name = ? WHERE id = ?'&#10;  const result = await allServices.query(sql, [newName, fileId])&#10;&#10;  return { success: result.affectedRows &gt; 0 }&#10;}&#10;&#10;// 复制文档&#10;const duplicateDocument = async (data) =&gt; {&#10;  const { fileId, newName, userId } = data&#10;&#10;  // 获取原文档信息和内容&#10;  const getDocSql = `&#10;    SELECT d.*, dc.content &#10;    FROM documents d&#10;    JOIN documents_content dc ON d.id = dc.document_id&#10;    WHERE d.id = ? AND d.status = 'active'&#10;  `&#10;  const [originalDoc] = await allServices.query(getDocSql, [fileId])&#10;&#10;  if (!originalDoc) {&#10;    throw new Error('原文档不存在')&#10;  }&#10;&#10;  // 创建新文档&#10;  const newDocumentId = nanoid()&#10;  const connection = await allServices.getConnection()&#10;&#10;  try {&#10;    await connection.beginTransaction()&#10;&#10;    // 1. 创建新文档记录&#10;    const insertDocSql = `&#10;      INSERT INTO documents (id, doc_name, owner_id, status) &#10;      VALUES (?, ?, ?, 'active')&#10;    `&#10;    await connection.query(insertDocSql, [newDocumentId, newName, userId])&#10;&#10;    // 2. 复制文档内容&#10;    const insertContentSql = `&#10;      INSERT INTO documents_content (document_id, content) &#10;      VALUES (?, ?)&#10;    `&#10;    await connection.query(insertContentSql, [newDocumentId, originalDoc.content])&#10;&#10;    // 3. 添加协作者记录&#10;    const insertCollaboratorSql = `&#10;      INSERT INTO document_collaborators (document_id, user_id, role) &#10;      VALUES (?, ?, 'owner')&#10;    `&#10;    await connection.query(insertCollaboratorSql, [newDocumentId, userId])&#10;&#10;    await connection.commit()&#10;&#10;    return { success: true, documentId: newDocumentId }&#10;  } catch (error) {&#10;    await connection.rollback()&#10;    throw error&#10;  } finally {&#10;    connection.release()&#10;  }&#10;}&#10;&#10;// 获取文档用于下载&#10;const getDocumentForDownload = async (data) =&gt; {&#10;  const { fileId, userId } = data&#10;&#10;  // 检查用户权限并获取文档内容&#10;  const sql = `&#10;    SELECT d.doc_name, dc.content&#10;    FROM documents d&#10;    JOIN documents_content dc ON d.id = dc.document_id&#10;    LEFT JOIN document_collaborators col ON d.id = col.document_id&#10;    WHERE d.id = ? &#10;      AND d.status = 'active'&#10;      AND (d.owner_id = ? OR col.user_id = ?)&#10;    LIMIT 1&#10;  `&#10;&#10;  const result = await allServices.query(sql, [fileId, userId, userId])&#10;&#10;  if (!result || result.length === 0) {&#10;    throw new Error('文档不存在或您没有访问权限')&#10;  }&#10;&#10;  return result[0]&#10;}&#10;&#10;module.exports = {&#10;  findContent,&#10;  getDocumentList,&#10;  createDocument,&#10;  deleteDocument,&#10;  renameDocument,&#10;  duplicateDocument,&#10;  getDocumentForDownload,&#10;}" />
              <option name="updatedContent" value="const { allServices } = require('../../config')&#10;const { nanoid } = require('nanoid')&#10;&#10;// 根据文件Id查找文件内容&#10;const findContent = (data) =&gt; {&#10;  // 1. 构建查询语句&#10;  const sql = 'SELECT content FROM documents_content WHERE document_id = ?'&#10;  // 2. 执行查询&#10;  return allServices.query(sql,[data.fileId])&#10;}&#10;&#10;// 获取用户的文档列表&#10;const getDocumentList = (userId) =&gt; {&#10;  // 查询用户创建的文档和作为协作者的文档&#10;  const sql = `&#10;    SELECT DISTINCT&#10;      d.id,&#10;      d.doc_name,&#10;      d.owner_id,&#10;      d.created_at,&#10;      d.updated_at,&#10;      CASE &#10;        WHEN d.owner_id = ? THEN 'owner'&#10;        ELSE 'editor'&#10;      END as role&#10;    FROM documents d&#10;    LEFT JOIN document_collaborators dc ON d.id = dc.document_id&#10;    WHERE d.status = 'active' &#10;      AND (d.owner_id = ? OR dc.user_id = ?)&#10;    ORDER BY d.updated_at DESC&#10;  `&#10;  // 执行查询，传入三个相同的userId参数&#10;  return allServices.query(sql, [userId, userId, userId])&#10;}&#10;&#10;// 创建新文档&#10;const createDocument = async (data) =&gt; {&#10;  const { name, userId } = data&#10;&#10;  // 生成唯一的文档ID&#10;  const documentId = nanoid()&#10;&#10;  // 开启事务 -- 专用连接&#10;  const connection = await allServices.getConnection()&#10;&#10;  try {&#10;    await connection.beginTransaction()&#10;&#10;    // 1. 插入文档基本信息&#10;    const insertDocSql = `&#10;      INSERT INTO documents (id, doc_name, owner_id, status) &#10;      VALUES (?, ?, ?, 'active')&#10;    `&#10;    await connection.query(insertDocSql, [documentId, name, userId])&#10;&#10;    // 2. 插入初始内容（空文档）&#10;    const insertContentSql = `&#10;      INSERT INTO documents_content (document_id, content) &#10;      VALUES (?, ?)&#10;    `&#10;    // 初始化一个空的 Tiptap 文档结构&#10;    const initialContent = JSON.stringify({&#10;      type: 'doc',&#10;      content: [{&#10;        type: 'paragraph',&#10;        content: []&#10;      }]&#10;    })&#10;    await connection.query(insertContentSql, [documentId, initialContent])&#10;&#10;    // 3. 将创建者添加到协作者表&#10;    const insertCollaboratorSql = `&#10;      INSERT INTO document_collaborators (document_id, user_id, role) &#10;      VALUES (?, ?, 'owner')&#10;    `&#10;    await connection.query(insertCollaboratorSql, [documentId, userId])&#10;&#10;    // 提交事务&#10;    await connection.commit()&#10;&#10;    return { success: true, documentId }&#10;  } catch (error) {&#10;    // 回滚事务&#10;    await connection.rollback()&#10;    throw error&#10;  } finally {&#10;    // 释放连接&#10;    connection.release()&#10;  }&#10;}&#10;&#10;// 删除文档（软删除）&#10;const deleteDocument = async (data) =&gt; {&#10;  const { fileId, userId } = data&#10;&#10;  // 先检查用户是否有权限删除（必须是文档所有者）&#10;  const checkOwnerSql = 'SELECT owner_id FROM documents WHERE id = ? AND status = &quot;active&quot;'&#10;  const [doc] = await allServices.query(checkOwnerSql, [fileId])&#10;&#10;  if (!doc) {&#10;    throw new Error('文档不存在')&#10;  }&#10;&#10;  if (doc.owner_id !== userId) {&#10;    throw new Error('您没有权限删除此文档')&#10;  }&#10;&#10;  // 执行软删除&#10;  const sql = 'UPDATE documents SET status = &quot;deleted&quot; WHERE id = ?'&#10;  const result = await allServices.query(sql, [fileId])&#10;&#10;  return { success: result.affectedRows &gt; 0 }&#10;}&#10;&#10;// 重命名文档&#10;const renameDocument = async (data) =&gt; {&#10;  const { fileId, newName, userId } = data&#10;&#10;  // 检查用户是否有权限（所有者或协作者都可以重命名）&#10;  const checkPermissionSql = `&#10;    SELECT 1 FROM documents d&#10;    LEFT JOIN document_collaborators dc ON d.id = dc.document_id&#10;    WHERE d.id = ? &#10;      AND d.status = 'active'&#10;      AND (d.owner_id = ? OR dc.user_id = ?)&#10;    LIMIT 1&#10;  `&#10;  const permission = await allServices.query(checkPermissionSql, [fileId, userId, userId])&#10;&#10;  if (!permission || permission.length === 0) {&#10;    throw new Error('您没有权限重命名此文档')&#10;  }&#10;&#10;  // 执行重命名&#10;  const sql = 'UPDATE documents SET doc_name = ? WHERE id = ?'&#10;  const result = await allServices.query(sql, [newName, fileId])&#10;&#10;  return { success: result.affectedRows &gt; 0 }&#10;}&#10;&#10;// 复制文档&#10;const duplicateDocument = async (data) =&gt; {&#10;  const { fileId, newName, userId } = data&#10;&#10;  // 获取原文档信息和内容&#10;  const getDocSql = `&#10;    SELECT d.*, dc.content &#10;    FROM documents d&#10;    JOIN documents_content dc ON d.id = dc.document_id&#10;    WHERE d.id = ? AND d.status = 'active'&#10;  `&#10;  const [originalDoc] = await allServices.query(getDocSql, [fileId])&#10;&#10;  if (!originalDoc) {&#10;    throw new Error('原文档不存在')&#10;  }&#10;&#10;  // 创建新文档&#10;  const newDocumentId = nanoid()&#10;  const connection = await allServices.getConnection()&#10;&#10;  try {&#10;    await connection.beginTransaction()&#10;&#10;    // 1. 创建新文档记录&#10;    const insertDocSql = `&#10;      INSERT INTO documents (id, doc_name, owner_id, status) &#10;      VALUES (?, ?, ?, 'active')&#10;    `&#10;    await connection.query(insertDocSql, [newDocumentId, newName, userId])&#10;&#10;    // 2. 复制文档内容&#10;    const insertContentSql = `&#10;      INSERT INTO documents_content (document_id, content) &#10;      VALUES (?, ?)&#10;    `&#10;    await connection.query(insertContentSql, [newDocumentId, originalDoc.content])&#10;&#10;    // 3. 添加协作者记录&#10;    const insertCollaboratorSql = `&#10;      INSERT INTO document_collaborators (document_id, user_id, role) &#10;      VALUES (?, ?, 'owner')&#10;    `&#10;    await connection.query(insertCollaboratorSql, [newDocumentId, userId])&#10;&#10;    await connection.commit()&#10;&#10;    return { success: true, documentId: newDocumentId }&#10;  } catch (error) {&#10;    await connection.rollback()&#10;    throw error&#10;  } finally {&#10;    connection.release()&#10;  }&#10;}&#10;&#10;// 获取文档用于下载&#10;const getDocumentForDownload = async (data) =&gt; {&#10;  const { fileId, userId } = data&#10;&#10;  // 检查用户权限并获取文档内容&#10;  const sql = `&#10;    SELECT d.doc_name, dc.content&#10;    FROM documents d&#10;    JOIN documents_content dc ON d.id = dc.document_id&#10;    LEFT JOIN document_collaborators col ON d.id = col.document_id&#10;    WHERE d.id = ? &#10;      AND d.status = 'active'&#10;      AND (d.owner_id = ? OR col.user_id = ?)&#10;    LIMIT 1&#10;  `&#10;&#10;  const result = await allServices.query(sql, [fileId, userId, userId])&#10;&#10;  if (!result || result.length === 0) {&#10;    throw new Error('文档不存在或您没有访问权限')&#10;  }&#10;&#10;  return result[0]&#10;}&#10;&#10;module.exports = {&#10;  findContent,&#10;  getDocumentList,&#10;  createDocument,&#10;  deleteDocument,&#10;  renameDocument,&#10;  duplicateDocument,&#10;  getDocumentForDownload,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>